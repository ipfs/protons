/* eslint-env mocha */

import { expect } from 'aegir/chai'
import Long from 'long'
import protobufjs from 'protobufjs'
import { MapTypes, type SubMessage, type EnumValue } from './fixtures/maps.js'

function longifyBigInts (obj: any): any {
  const output = {
    ...obj
  }

  for (const key of Object.keys(output)) {
    if (typeof output[key] === 'bigint') {
      output[key] = Long.fromString(`${output[key].toString()}`)
    }
  }

  return output
}

function bigintifyLongs (obj: any): any {
  const output = {
    ...obj
  }

  for (const key of Object.keys(output)) {
    if (output[key]?.low != null && output[key]?.high != null) {
      output[key] = BigInt(new Long(output[key].low, output[key].high, output[key].unsigned).toString())
    }
  }

  return output
}

function uint8ArrayifyBytes (obj: any): any {
  const output = {
    ...obj
  }

  for (const key of Object.keys(output)) {
    if (output[key] instanceof Uint8Array) {
      output[key] = Uint8Array.from(output[key])
    }
  }

  return output
}

function objectifyMaps (obj: any): any {
  const output = {
    ...obj
  }

  for (const key of Object.keys(output)) {
    if (output[key] instanceof Map) {
      const obj: Record<any, any> = {}
      const entries: Array<[key: any, value: any]> = output[key].entries()

      for (const [key, value] of entries) {
        obj[key] = value
      }

      output[key] = obj
    }
  }

  return output
}

/**
 * Paper over differences between protons and protobuf.js output
 */
function normalizeProtonbufjs (obj: any, target: any): any {
  let output = bigintifyLongs(obj)
  output = uint8ArrayifyBytes(output)

  for (const key of Object.keys(output)) {
    // protobujs sets unset message fields to `null`, protons does not set the field at all
    if (output[key] === null && target[key] == null) {
      delete output[key] // eslint-disable-line @typescript-eslint/no-dynamic-delete
    }
  }

  for (const key of Object.keys(target)) {
    // protobujs uses plain objects instead of maps
    if (target[key] instanceof Map) {
      output[key] = new Map(Object.entries(output[key] ?? {}))
    }
  }

  return output
}

interface TestEncodingOptions {
  compareBytes?: boolean
  comparePbjs?: boolean
}

/**
 * Ensure:
 *
 * 1. the generated bytes between protons, pbjs and protobuf.js are the same
 * 2. protons and protobuf.js agree on deserialization
 */
function testEncodings (obj: any, protons: any, proto: string, typeName: string, opts: TestEncodingOptions = {}): void {
  const protobufJsSchema = protobufjs.loadSync(proto).lookupType(typeName)
  const protobufJsBuf = protobufJsSchema.encode(protobufJsSchema.fromObject(objectifyMaps(longifyBigInts(obj)))).finish()

  const encoded = protons.encode(obj)

  if (opts.compareBytes !== false) {
    expect(encoded).to.equalBytes(protobufJsBuf)
  }

  expect(protons.decode(encoded)).to.deep.equal(obj)
  expect(protons.decode(protobufJsBuf)).to.deep.equal(obj)

  expect(normalizeProtonbufjs(protobufJsSchema.toObject(protobufJsSchema.decode(encoded), {
    enums: String,
    defaults: true
  }), obj)).to.deep.equal(obj)
}

describe('maps', () => {
  it('should encode all the types', () => {
    const obj: MapTypes = {
      stringMap: new Map<string, string>(),
      intMap: new Map<number, number>(),
      boolMap: new Map<boolean, boolean>(),
      messageMap: new Map<string, SubMessage>(),
      enumMap: new Map<string, EnumValue>()
    }

    testEncodings(obj, MapTypes, './test/fixtures/maps.proto', 'MapTypes')
  })

  it('should encode all the types with values', () => {
    const obj: MapTypes = {
      stringMap: new Map<string, string>([['key', 'value']]),
      intMap: new Map<number, number>(), // protobuf.js only supports strings as keys
      boolMap: new Map<boolean, boolean>(), // protobuf.js only supports strings as keys
      messageMap: new Map<string, SubMessage>([['key', { foo: 'bar', bar: [] }]]),
      enumMap: new Map<string, EnumValue>()
    }

    testEncodings(obj, MapTypes, './test/fixtures/maps.proto', 'MapTypes')
  })

  it('should limit map sizes using runtime options', () => {
    const obj: MapTypes = {
      stringMap: new Map<string, string>([['key', 'value'], ['foo', 'bar']]),
      intMap: new Map<number, number>(),
      boolMap: new Map<boolean, boolean>(),
      messageMap: new Map<string, SubMessage>(),
      enumMap: new Map<string, EnumValue>()
    }

    const buf = MapTypes.encode(obj)
    expect(() => MapTypes.decode(buf, {
      limits: {
        stringMap: 1
      }
    })).to.throw(/too many elements/)
  })

  it('should limit nested message collection sizes using runtime options', () => {
    const obj: MapTypes = {
      stringMap: new Map<string, string>(),
      intMap: new Map<number, number>(),
      boolMap: new Map<boolean, boolean>(),
      messageMap: new Map<string, SubMessage>([['foo', { foo: 'hello', bar: [1, 2, 3, 4, 5] }]]),
      enumMap: new Map<string, EnumValue>()
    }

    const buf = MapTypes.encode(obj)
    expect(() => MapTypes.decode(buf, {
      limits: {
        messageMap$value: {
          bar: 1
        }
      }
    })).to.throw(/too many elements/)
  })
})
